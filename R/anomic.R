#  Generated by LaTeX DogWagger Version 4.0.5 from file <anomic_100.tex>
#  Date: [2025-11-17 13:35:4] 
#  Do NOT edit this file. Edit the LaTeX source!!

#  - <Section 1> - 
 #' ANOM --- Analysis of Means
#' 
#' @description
#' This function is a wrapper for the various supported classes. 
#' 
#' @param mc An object of class glht, SimCi, mctp or binomRDci
#' @param ... Additional arguments passed to the various methods 
#' 
#' @return This function returns a ggplot2 ANOM object 
#' @export 
anomic <- function(mc, ...) {
  UseMethod("anomic")
}

#  - <Section 2> - 
 #' ANOM for General Linear Hypotheses
#'
#' This function uses the multcomp package. A glht object supports a multitude of models 
#'   that include parametric models, glms, linear mixed effects and survival models. 
#'   At the start, we test for a 'grandMean' because this is required for the center line 
#'   of the plot and the calculations. 
#' 
#' @param mc An object of class glht 
#' @param xlabel An optional character string specifying the label of the horizontal axis. 
#' @param ylabel An optional character string specifying the label of the vertical axis.
#' @param printn A logical. Should per-group sample sizes be included in the chart? Default TRUE.
#' @param printp A logical. Should simultaneous p-values be included in the chart? Default TRUE.
#' @param drawplot A logical. Whether to explictly print() the resulting plot. Default is TRUE. 
#' @param epsilon A number. Precision used in calculating displayed p-values for glht model. Default 1e-3. 
#' @param ... Additional arguments passed to anomic.glht 
#' 
#' @return This function returns a ggplot2 ANOM object 
#' @importFrom multcomp adjusted glht mcp 
#' @importFrom stats binomial confint poisson predict 
#' @export 

anomic.glht <- function(mc, xlabel = NULL, ylabel = NULL, printn = TRUE, printp = TRUE, 
    drawplot = TRUE, epsilon = 1e-3, ...) {

    if (mc$type != "GrandMean") {
        stop("For ANOM you need a 'GrandMean' contrast matrix!")
    }
    modclass <- attr(mc$model, "class")[1]
    if (modclass == "aov" | modclass == "lm" | modclass == "glm") {
        dd <- attr(attr(mc$model$terms, "factors"), "dimnames")[[1]][1]
        ii <- attr(attr(mc$model$terms, "factors"), "dimnames")[[1]][2]
        dep <- mc$model$model[dd][, 1]
        ind <- mc$model$model[ii][, 1]
    }
    if (modclass == "lme") {
        dd <- attr(attr(mc$model$terms, "factors"), "dimnames")[[1]][1]
        ii <- attr(attr(mc$model$terms, "factors"), "dimnames")[[1]][2]
        dep <- mc$model$data[, dd]
        ind <- mc$model$data[, ii]
    }
    if (modclass == "lmerMod") {
        dd <- rownames(attr(attr(mc$model@frame, "terms"), 
            "factors"))[1]
        ii <- rownames(attr(attr(mc$model@frame, "terms"), 
            "factors"))[2]
        dep <- mc$model@frame[, dd]
        ind <- mc$model@frame[, ii]
    }

#  - <Section 3> - 
     ss <- as.vector(tapply(ind, ind, length)) # equivalent to as.vector(table(ind)) 
    ci <- confint(mc)

    # depending on model and sub-type, extract vector of means, mea
    if (modclass != "glm") {
        means <- as.vector(tapply(dep, ind, mean))
        mea <- mean(dep)
    }

#  - <Section 4> - 
     if (modclass == "glm") {
        if (mc$model$family$family == "poisson") {
            cit <- apply(ci$confint, 2, poisson()$linkinv)
            m <- mean(poisson()$linkinv(predict(mc$model)))
        }
        if (mc$model$family$family == "binomial") {
            cit <- apply(ci$confint, 2, binomial()$linkinv)
            m <- mean(binomial()$linkinv(predict(mc$model)))
        }
    }

#  - <Section 5> - 
      if(is.null(xlabel) == TRUE) 
        { xlabel <- ii
        }; 
      if(is.null(ylabel) == TRUE) 
        { ylabel <- dd
        }; 
        
        if (printp == TRUE) {
            pvals <- summary(mc, test = adjusted(abseps = epsilon))$test$pvalues[1:length(ss)]
        }
        else {
            pvals <- NULL
        }

#  - <Section 6> - 
    if (modclass != "glm") {
        if (modclass == "lmerMod") {
            return(anomic_gen(mu = means, n = ss, 
                      lo = ci$confint[, "lwr"], up = ci$confint[, "upr"], 
                      names = levels(mc$model@frame[, ii]),
                      alternative = mc$alternative, 
                      xlabel = xlabel, ylabel = ylabel, 
                      printn = printn, p = pvals, 
                      drawplot = drawplot, ...))
        } 

#  - <Section 7> - 
     else {
        return(anomic_gen(mu = means, n = ss, 
              lo = ci$confint[, "lwr"], up = ci$confint[, "upr"], 
              names = mc$model$xlevels[[1]], 
              alternative = mc$alternative, 
              xlabel = xlabel, ylabel = ylabel, 
              printn = printn, p = pvals, 
              drawplot = drawplot, ...))
    }
}

#  - <Section 8> - 
     if (modclass == "glm") {
        if (mc$model$family$family == "poisson") {
            lower_bound = m * cit[, 2] - m
            upper_bound = m * cit[, 3] - m
            group_means = m * cit[, 1]
        }
        if (mc$model$family$family == "binomial") {
            lower_bound = cit[, 2] - m
            upper_bound = cit[, 3] - m
            group_means = cit[, 1]
        } 
        if (mc$alternative == "greater") {
            upper_bound = Inf
        }  
        if (mc$alternative == "less") {
              lower_bound = -Inf
        }
        
        return( anomic_gen(mu = group_means, n = ss, gm = m, 
                   lo = lower_bound, up = upper_bound, 
                   names = mc$model$xlevels[[1]], 
                   alternative = mc$alternative, 
                   xlabel = xlabel, ylabel = ylabel,
                   printn = printn, p = pvals, 
                   whichone = "glm", drawplot = drawplot, ...) )
    }
}      

#  - <Section 9> - 
 #' ANOM for SimComp: Simultaneous Testing with Confidence Intervals. 
#'
#' This function works with the SimComp package, which allows for simultaneous testing 
#'   with confidence intervals. This is only for one way experimental designs with 
#'   normally distributed primary response variables. 
#' 
#' @param mc An object of class SimCi 
#' @param xlabel An optional character string specifying the label of the horizontal axis. 
#' @param ylabel An optional character string specifying the label of the vertical axis.
#' @param printn A logical. Should per-group sample sizes be included in the chart? Default TRUE.
#' @param printp A logical. Should simultaneous p-values be included in the chart? Default TRUE.
#' @param drawplot A logical. Whether to explictly print() the resulting plot. Default is TRUE. 
#' @param stdep A numerical vector giving the values of the dependent variable.
#' @param stind A factor specifying the levels of the independent variable. 
#' @param pst An object of class SimTest. Only required simultaneous p-values are to be printed. 
#' @param ... Additional arguments passed to anomic.SimCi 
#' 
#' @return This function returns a ggplot2 ANOM object 
#' @importFrom SimComp SimCiRat SimCiDiff 
#' @importFrom methods is 
#' @export 

anomic.SimCi <- function(mc, xlabel = NULL, ylabel = NULL, printn = TRUE, printp = TRUE, 
    stdep = NULL, stind = NULL, pst = NULL, drawplot = TRUE, ...) {

        # Sanity checks
        if (mc$type != "GrandMean") {
            stop("For ANOM you need a 'GrandMean' contrast matrix!")
        }
        if (is.null(stdep) == TRUE) {
            stop("Please insert a vector giving the values\n\n
              of the dependent variable for stdep!")
        }
        if (is.null(stind) == TRUE) {
            stop("Please insert a numeric vector giving the values\n\n
              of the independent variable for stind!")
        }
        if (is.numeric(stdep) == FALSE) {
            stop("The dependent variable must be numeric.")
        }
        if ((length(stdep) == length(stind)) == FALSE) {
            stop("Dependent and independent variable must be vectors of equal length.")
        }

#  - <Section 10> - 
         stind <- as.factor(stind)
        ss <- as.vector(tapply(stdep, stind, length))

        if (mc$test.class == "ratios") {
            grame <- 100
        }
        else {
            grame <- mean(stdep)
        }

        # Label checking / fill in if null
        if (is.null(xlabel) == TRUE) {
            xlabel <- "group"
        }
        else {
            xlabel <- xlabel
        }
        if (is.null(ylabel) == TRUE) {
            ylabel <- mc$resp
        }
        else {
            ylabel <- ylabel
        }

        if (printp == TRUE) {
            if ( ! is(pst,"SimTest") ) {
            # if (class(pst) != "SimTest") {
                stop("Please insert an object of class 'SimTest' for pst,\n\n
                        or set printp to 'FALSE'.")
            }
            ppp <- pst$p.val.adj[1:length(ss)]
        }
        else {
            ppp <- NULL
        }

#  - <Section 11> - 
        if (mc$test.class == "ratios") {
            return(anomic_gen(mu = 100 * as.vector(mc$estimate), n = ss, 
                lo = 100 * as.vector(mc$lower), up = 100 * as.vector(mc$upper), 
                alternative = mc$alternative, xlabel = xlabel, 
                ylabel = ylabel, printn = printn, p = ppp, 
                whichone = "ratio", drawplot = drawplot, ... ))
        }

#  - <Section 12> - 
         else {
            return(anomic_gen(mu = as.vector(mc$estimate) + grame, n = ss, 
                lo = as.vector(mc$lower), up = as.vector(mc$upper), 
                alternative = mc$alternative, xlabel = xlabel, 
                ylabel = ylabel, printn = printn, p = ppp, 
                drawplot = drawplot, ... ))
        }
    }

#  - <Section 13> - 
 #' ANOM for mctp: Non-parametric Confidence Intervals
#'
#' This function provides ANOM for the nparcomp package. The mctp function is used 
#'    to determine non-parametric confidence intervals, which assumes an unbalanced one-way layout. 
#' 
#' @param mc An object of class mctp 
#' @param xlabel An optional character string specifying the label of the horizontal axis. 
#' @param ylabel An optional character string specifying the label of the vertical axis.
#' @param printn A logical. Should per-group sample sizes be included in the chart? Default TRUE.
#' @param printp A logical. Should simultaneous p-values be included in the chart? Default TRUE.
#' @param drawplot A logical. Whether to explictly print() the resulting plot. Default is TRUE. 
#' @param ... Additional arguments passed to anomic.mctp 
#' 
#' @return This function returns a ggplot2 ANOM object 
#' @importFrom nparcomp mctp 
#' @importFrom stats binomial confint poisson predict weighted.mean 
#' @export 

anomic.mctp <- function(mc, xlabel = NULL, ylabel = NULL, printn = TRUE, printp = TRUE, 
    drawplot = TRUE, ...) {
        
     if(  (mc$input$type != "GrandMean") 
       &&( (mc$input$type != "UserDefined")
         ||(attributes(mc$input$contrast.matrix)$type != "GrandMean")
         ) 
       )
       { stop("For ANOM you need a 'GrandMean' contrast matrix!")
       } 
     if(is.null(mc$Correlation) == TRUE) 
       { stop("Set the argument 'correlation' in function 'mctp()' to 'TRUE'.")
       }
     if(is.null(xlabel) == TRUE) 
       { xlabel <- as.character(mc$input$formula[3])
       } else 
       { xlabel <- xlabel
       }
     if(is.null(ylabel) == TRUE) 
       { ylabel <- as.character(mc$input$formula[2])
       } else 
       { ylabel <- ylabel
       }
        if (printp == TRUE) {
            pvals <- mc$Analysis$p.Value
        } else {
          pvals <- NULL
        }

#  - <Section 14> - 
         if (mc$input$alternative == "two.sided") {
          lower_bound = mc$Analysis$Lower
          upper_bound = mc$Analysis$Upper
        }

        if (mc$input$alternative == "greater") {
          lower_bound = mc$Analysis$Lower
          upper_bound = Inf
        }  

        if (mc$input$alternative == "less") {
          lower_bound = Inf # TODO Check this? Should be -Inf??
          upper_bound = mc$Analysis$Upper
        }

        return(anomic_gen(mu = mc$Data.Info$Effect, n = mc$Data.Info$Size, 
            lo = lower_bound, up = upper_bound, 
            names = colnames(mc$Contrast), alternative = mc$input$alternative, 
            xlabel = xlabel, ylabel = ylabel, 
            printn = printn, p = pvals, drawplot = drawplot, ...))
}      

#  - <Section 15> - 
 #' ANOM for MCPAN: Binomial Distributions
#'
#' This function works with MCPAN. The binomRDci function in MCPAN addresses binomial distributions, 
#'    allowing calculation of simultaneous asymptotic confidence intervals. Note that 
#'    MCPAN uses normal approximation. 
#' 
#' @param mc An object of class glht 
#' @param xlabel An optional character string specifying the label of the horizontal axis. 
#' @param ylabel An optional character string specifying the label of the vertical axis.
#' @param printn A logical. Should per-group sample sizes be included in the chart? Default TRUE.
#' @param printp A logical. Should simultaneous p-values be included in the chart? Default TRUE.
#' @param pbin An object of class binomRDtest. Required if printp=TRUE. Default NULL.
#' @param drawplot A logical. Whether to explictly print() the resulting plot. Default is TRUE. 
#' @param ... Additional arguments passed to anomic.binomRDci 
#' 
#' @return This function returns a ggplot2 ANOM object 
#' @importFrom MCPAN binomRDci binomRDtest 
#' @importFrom methods is 
#' @export 

anomic.binomRDci <- function(mc, xlabel = NULL, ylabel = NULL, printn = TRUE, printp = TRUE, 
    pbin = NULL, drawplot = TRUE, ...) {
        if (attr(mc$cmat, "type") != "GrandMean") {
            stop("For ANOM you need a 'GrandMean' contrast matrix!")
        }
        if (is.null(xlabel) == TRUE) {
            xlabel <- "group"
        }
        else {
            xlabel <- xlabel
        }
        if (is.null(ylabel) == TRUE) {
            ylabel <- "probability of success"
        }
        else {
            ylabel <- ylabel
        }
        if (printp == TRUE) {
            if ( ! is(pbin,"binomRDtest") ) {
            # if (class(pbin) != "binomRDtest") {
                stop("Please insert an object of class 'binomRDtest' for pbin,\n\n
                        or set printp to 'FALSE'.")
            }
            ppp <- pbin$p.val.adj
        }
        else {
            ppp <- NULL
        }

#  - <Section 16> - 
         return(anomic_gen(mu = mc$p, n = mc$n, 
                  lo = mc$conf.int[, "lower"], up = mc$conf.int[, "upper"],
                  names = mc$names, alternative = mc$alternative, 
                  xlabel = xlabel, ylabel = ylabel, 
                  printn = printn, p = ppp, 
                  drawplot = drawplot, ... ))
    }

#  - <Section 17> - 
#' General ANOM plotting function
#'
#' This function creates a plotting object using the supplied parameters, and then 
#'   invokes ggplot()
#' 
#' @param mu A numeric vector of group means 
#' @param n A numeric vector of sample sizes per group. Either n or gm must be provided.
#' @param gm A single numeric value giving the grand mean of all groups. Either n or gm must be provided.
#' @param lo A numeric vector of lower (simultaneous) confidence interval bounds for comparisons to the grand mean.
#' @param up A numeric vector of upper (simultaneous) confidence interval bounds for comparisons to the grand mean.
#' @param names An (optional) vector of characters specifying the groups' names.
#' @param alternative A character string indicating the direction of the alternative hypothesis. Default is "two.sided", but may be changed to one-sided alternatives (either "greater" or "less").
#' @param xlabel An optional character string specifying the label of the horizontal axis. 
#' @param ylabel An optional character string specifying the label of the vertical axis.
#' @param printn A logical. Should per-group sample sizes be included in the chart? Default TRUE.
#' @param p An (optional) numeric vector of (simultaneous) p-values to be printed.
#' @param whichone A string, one of "glm" or "ratio"; for glm in glht or ratios with SimCi. 
#' @param drawplot A logical. If TRUE (default) draw the plot; otherwise don't. 
#' @param psize A single numeric value giving the size of points
#' @param title A string. What to title the plot
#' @param dlstyle An object. Either a character string which is used as a linetype or a list of attributes to pass to geom_line
#' @param ... Additional arguments passed to anom_gen 
#'
#' @return This function returns a ggplot2 ANOM graphical object 
#' @importFrom ggplot2 ggplot aes geom_point geom_rect geom_segment annotate scale_x_discrete xlab ylab labs ylim geom_text 
#' @importFrom methods is 
#' @export 

anomic_gen <- function (mu, n = NULL, gm = NULL, lo, up, names = NULL, alternative = "two.sided", 
    xlabel = "Group", ylabel = "Endpoint", printn = TRUE, p = NULL, whichone = NULL, 
    drawplot = TRUE, psize = 5, title = NULL, dlstyle = "dashed", ...) 
{  
    
    # ellipsis resolution! 
    ellipsis <- list(...)
    if (is.null(ellipsis$fill)) ellipsis$fill <- "darkgray"
    if (is.null(ellipsis$alpha)) ellipsis$alpha <- 0.5
    if (is.null(ellipsis$linewidth)) ellipsis$linewidth <- 1 
    if (is.null(ellipsis$size)) ellipsis$size <- 5

    if( ! is(dlstyle,"list") ) {
    # if (class(dlstyle) != "list") {
        dlstyle = list(linetype = dlstyle, linewidth = ellipsis$linewidth)
    }


#  - <Section 18> - 
all_geometries <- list("geom_rect", "geom_text", "geom_segment", "geom_point")
all_good_args <- unique(unlist(lapply(all_geometries, anomic_good_args)))
unused_args <- setdiff(names(ellipsis), all_good_args)

if (length(unused_args) > 0) {
    warning(paste("Unused Arguments", unused_args))
}

#  - <Section 19> - 
     if (is.null(whichone) || whichone == "ratio") {
        if (is.null(gm)) {
                gm <- weighted.mean(mu, n)
            }
            if (!(is.null(n)) & !(is.null(gm))) {
                check <- abs(weighted.mean(mu, n) - gm)
                if (check > 0.01) {
                    stop("The 'gm' value you inserted is not the grand mean\n\n
                            computed from your 'mu' and 'n' values!")
                }
            }
    }

    grp <- 1:length(mu)
    grpf <- as.factor(grp)
    
    if (!(is.null(names))) {
        names <- as.factor(names)
    }
    else {
        names <- grpf
    }

#  - <Section 20> - 
    if (is.null(n)) {
        stop("Missing Group sizes")
    }
    if (!(is.null(p))) {
        printp <- TRUE
        p <- paste("p=", round(p, 3), sep = "")
        p[p == "p=0"] <- "p<0.001"
    }
    else {
        printp <- FALSE
    }

#  - <Section 21> - 
    dir <- match.arg(alternative, choices = c("two.sided", "greater", "less"))
    if (dir == "two.sided") {
        if (all(lo == -Inf) | all(lo == -1) | all(lo == 0) | 
            all(up == 1) | all(up == Inf)) {
            warning("Is your alternative really 'two.sided'? Doesn't seem so!")
        }
    }

    # Insert for whichone customisation: 
    if(  (! is.null(whichone) )
      && (whichone == "ratio") 
      ) 
    {
        ldl <- gm - abs(mu - up)
        udl <- gm + abs(mu - lo)
    }
    else {
        ldl <- gm - abs((mu - gm) - up)
        udl <- gm + abs((mu - gm) - lo)
    }

#  - <Section 22> - 
     if (printp == TRUE) {
        if (printn == TRUE) {
            set <- data.frame(mu, gm, lo, up, ldl, udl, grp, 
                grpf, names, n, p)
        }
        else {
            set <- data.frame(mu, gm, lo, up, ldl, udl, grp, 
                grpf, names, p)
        }
    }
    else {
        if (printn == TRUE) {
            set <- data.frame(mu, gm, lo, up, ldl, udl, grp, 
                grpf, names, n)
        }
        else {
            set <- data.frame(mu, gm, lo, up, ldl, udl, grp, 
                grpf, names)
        }
    }

#  - <Section 23> - 
    shading <- anomic_nicely(geom_rect, 
                     list(aes(xmin = grp - 0.5, 
                              xmax = grp + 0.5, 
                              ymin = ldl, 
                              ymax = udl),  
                              linetype = 0), 
                     ellipsis) 

    uplimit <- anomic_nicely(geom_segment,
                     list(aes(x = grp - 0.5, 
                              xend = grp + 0.5, 
                              y = udl, 
                              yend = udl)), 
                     dlstyle,
                     "alpha") 

    uplabel <- anomic_nicely(annotate, 
                     list(geom = "text", 
                       label = "UDL", 
                       x = max(grp) + 0.4, 
                       y = udl[max(grp)], 
                       size = ellipsis$size * 0.8, 
                       vjust = -0.75), 
                     ellipsis, 
                     c("alpha", "size")) 

    downlimit <- anomic_nicely(geom_segment, 
                     list(aes(x = grp - 0.5, 
                          xend = grp + 0.5, 
                          y = ldl, 
                          yend = ldl)), 
                     dlstyle,
                     "alpha") 

    downlabel <- anomic_nicely(annotate, 
                     list(geom = "text", 
                          label = "LDL", 
                          x = max(grp) + 0.4, 
                          y = ldl[max(grp)], 
                          size = ellipsis$size * 0.8, 
                          vjust = 1.5), 
                     ellipsis, 
                     c("alpha", "size"))

    grandmean <- anomic_nicely(geom_segment, 
                     list(aes(x = 0.5, 
                              xend = max(grp) + 0.5, 
                              y = gm, 
                              yend = gm)),
                     ellipsis,
                     "alpha") 

    offline <- anomic_nicely(geom_segment,
                     list(aes(x = grp, 
                              xend = grp, 
                              y = mu, 
                              yend = gm)),
                          ellipsis,
                          "alpha")

    mydot <- anomic_nicely(geom_point, 
                     list(size = psize),
                     ellipsis,
                     c("alpha", "size"))
      
    basic <- ggplot(set, aes(x = grpf, y = mu)) + 
               scale_x_discrete(labels = names) + 
               xlab(xlabel) + ylab(ylabel) + labs(title = title)
    
    basic <- basic + shading + grandmean + offline + mydot

#  - <Section 24> - 
     if (dir == "two.sided") {
        two_sided_ylim <- ylim(min(min(mu), min(ldl)) - (gm - min(min(mu), min(ldl)))/5, 
                 max(max(mu), max(udl)) + (max(max(mu), max(udl)) - gm)/5) 
        basic <- basic + uplimit + uplabel + downlimit + downlabel + two_sided_ylim
    }

#  - <Section 25> - 
     if (dir == "greater") {
        greater_ylim <- ylim((min(mu) - (gm - min(mu))/5)[1], 
                            (max(max(mu), max(udl)) + (max(max(mu), max(udl)) - gm)/5)[1])
        basic <- basic + uplimit + uplabel + greater_ylim 
    }

#  - <Section 26> - 
     if (dir == "less") {
        less_ylim <- ylim((min(min(mu), min(ldl)) - (gm - min(min(mu), min(ldl)))/5)[1], 
                          (max(mu) + (max(mu) - gm)/5)[1])
        basic <- basic + downlimit + downlabel + less_ylim
    }

#  - <Section 27> - 
     if (dir == "greater") {
        nlabelpos <- min(mu)
    }
    else {
        nlabelpos <- min(min(mu), min(ldl))
    }
    if (dir == "less") {
        plabelpos <- max(mu)
    }
    else {
        plabelpos <- max(max(mu), max(udl))
    }

    npart <- anomic_nicely(geom_text, 
                           list(aes(y = nlabelpos, label = paste("n=", n, sep = "")), 
                           vjust = 3), 
                           ellipsis, "alpha") 

    ppart <- anomic_nicely(geom_text, 
                           list(aes(y = plabelpos, label = p), 
                           vjust = -2),
                           ellipsis, "alpha") 

    if (printn == TRUE) {
        basic <- basic + npart
    }
    if (printp == TRUE) {
        basic <- basic + ppart
        }
    basic <- basic + anom_theme()

    if (drawplot) {
        print(basic)
    }
    
    return(basic)
}

#  - <Section 28> - 
 #' Filter out required plot parameters from submitted list(...) 
#' 
#' Suppress "Ignoring unknown parameters" by only submitting parameters relevant to supplied 'fun'. 
#'   Then invoke fun on the combination of the supplied arguments and the filtered ellipsis. 
#'   The ellipsis can contain both aesthetics and formal arguments. 
#' 
#' @param fun A first-order function like geom_rect()
#' @param arglist Fixed arguments for fun 
#' @param ellipsis Supplied list() of ellipsis, previously allocated using list(...) 
#' @param exclude Parameters to exclude from the ellipsis list 
#' 
#' @return This function returns the output from invocation of the first, 'fun' argument 
#' @export 
  
anomic_nicely <- function (fun, arglist = NULL , ellipsis = NULL, exclude = c()) 
{ # get argument names, excluding common ggplot ones: 
  valid_args <- names(formals(fun))

  # next, the valid aesthetics, which is more tricky: 
  fun_name <- deparse(substitute(fun)) # get function name, convert to string 

  if (grepl("^geom_", fun_name)) {
    geom_class_name <- sub("geom_(.)", "Geom\\U\\1", fun_name, perl = TRUE)
  } 
  else if (fun_name == "annotate") {
    geom = arglist$geom
    if (is.null(geom)) {
      stop("annotate() needs a 'geom' argument")
    }
    geom_class_name <- paste0("Geom", tools::toTitleCase(geom))
  }
  else {
    stop(paste("Wrapper anomic_nicely doesn't work for", fun_name))
  } 

#  - <Section 29> - 
   geom_class <- get(geom_class_name, envir = asNamespace("ggplot2") )
  valid_aes <- names(geom_class$default_aes) 

  valid_args <- unique( c(valid_aes, valid_args) ) 
  valid_args <- setdiff( valid_args, c("mapping", "data", "...", exclude) ) # ? needed ?? 

  # retain just valid arguments: 
  filtered <- ellipsis[names(ellipsis) %in% valid_args] 

  foo <- do.call( fun, c(arglist, filtered) ) 
  return(foo) 
}  

#  - <Section 30> - 
 #' Given a specific geometry function, list all valid arguments.
#' 
#' This combines regular arguments and aesthetics into one list
#' 
#' @param fun_name A string that defines the name of a first-order function like "geom_rect"
#' 
#' @return A list of strings representing valid arguments
#' @export 
  
anomic_good_args <- function (fun_name) 
{   valid_args <- names(formals(fun_name))
    geom_class_name <- sub("geom_(.)", "Geom\\U\\1", fun_name, perl = TRUE)
    geom_class <- get(geom_class_name, envir = asNamespace("ggplot2") )
    valid_aes <- names(geom_class$default_aes) 
    valid_args <- unique( c(valid_aes, valid_args) )
    return(valid_args)
}

#  - <Section 31> - 
 #' The standard theme for our ANOM plot
#'
#' This function creates a ggplot2 theme based on theme_bw() 
#' 
#' @param ... Additional arguments passed to anom_theme 
#' 
#' @return This function returns the new theme
#' @importFrom ggplot2 ggplot aes geom_point geom_rect geom_segment annotate scale_x_discrete xlab ylab labs ylim geom_text 
#' @importFrom ggplot2 theme element_text element_line theme_bw 
#' @export 
anom_theme <- function(...) { 
    theme_bw(...) + theme(axis.text.x = element_text(size = 18), 
                  axis.text.y = element_text(size = 18), 
                  axis.title.x = element_text(size = 25), 
                  axis.title.y = element_text(size = 25), 
                  panel.grid = element_line())
} 
#  -END OF FILE- 
