#  Generated by LaTeX DogWagger Version 4.0.5 from file <anomic_100.tex>
#  Date: [2025-11-17 13:35:4] 
#  Do NOT edit this file. Edit the LaTeX source!!

#  - <Section 43> - 
 
test_that("bad class fails on null", {
     expect_error(anomic(NULL),
        "no applicable method for 'anomic' applied to an object of class \"NULL\"")
})

test_that("bad class fails on invalid class", {
     expect_error(anomic(waterfilter),
        "no applicable method")
})


library(multcomp)
model <- lm(colonies ~ brand, waterfilter)
hom <- glht(model, mcp(brand="GrandMean"), alternative="less")

test_that("Unused Arguments", {
     expect_warning(anomic(hom, abc = 5))
})

test_that("Example generates plot", {
    expect_type(anomic(hom), "object")
})

test_that("Example generates plot", {
    expect_type(anomic(hom, printn = FALSE), "object")
})

test_that("No p-values is valid", {
    expect_type(anomic(hom, printp = FALSE, printn = FALSE), "object")
})

## glht method (multcomp)
bad_hom <- glht(model, mcp(brand="Tukey"), alternative="less")

test_that("glht fails on wrong contrast matrix type", {
    expect_error(anomic.glht(bad_hom), "GrandMean")
})

library(nlme)
esmodel1 <- lme(effort ~ Type, random=~1|Subject, data=ergoStool)
es1 <- glht(esmodel1, mcp(Type="GrandMean"), alternative="two.sided")

test_that("LME model produces plot", {
    expect_type(anomic(es1), "object")
})

library(lme4)
esmodel2 <- lmer(effort ~ Type + (1|Subject), data=ergoStool)
es2 <- glht(esmodel2, mcp(Type="GrandMean"), alternative="two.sided")

test_that("LMER model produces plot", {
    expect_type(anomic(es2), "object")
})

binmodel <- glm(cbind(proficient, enrolled - proficient) ~ school, data = math, family = binomial)
bincomp <- glht(binmodel, mcp(school="GrandMean"))
bincompless <- glht(binmodel, mcp(school="GrandMean"), alternative = "less")
bincompgreater <- glht(binmodel, mcp(school="GrandMean"), alternative = "greater")

# [could check] that inv link is being done
test_that("Binomial GLM model produces plot", {
    expect_type(anomic(bincomp), "object")
})

test_that("Binomial one sided (less) produces plot", {
    expect_type(anomic(bincompless), "object")
})

test_that("Binomial one sided (greater) produces plot", {
    expect_type(anomic(bincompgreater), "object")
})


data(InsectSprays)
InsectSprays$block <- as.factor(rep(1:6, each=2))
insmodel2 <- glm(count ~ spray + block, data=InsectSprays,
                 family=poisson(link="log"))
ins <- glht(insmodel2, mcp(spray="GrandMean"))

test_that("Poisson model produces plot", {
    expect_type(anomic(ins), "object")
})



## SimCi (SimComp)
library(SimComp)
het2 <- SimCiDiff(data=waterfilter, grp="brand", resp="colonies",
                  type="GrandMean", alternative="less", covar.equal=FALSE)
het2p <- SimTestDiff(data=waterfilter, grp="brand", resp="colonies",
                     type="GrandMean", alternative="less", covar.equal=FALSE)

tukey_het2 <- SimCiDiff(data=waterfilter, grp="brand", resp="colonies",
                  type="Tukey", alternative="less", covar.equal=FALSE)


# t_het2 <- anomic(het2, stdep=waterfilter$colonies, stind=waterfilter$brand, pst=het2p)

test_that("SimCi produces plot", {
    expect_type(anomic(het2, stdep=waterfilter$colonies, stind=waterfilter$brand, pst=het2p), "object")
})


rel <- SimCiRat(data=waterfilter, grp="brand", resp="colonies",
                type="GrandMean", alternative="less", covar.equal=TRUE)
relp <- SimTestRat(data=waterfilter, grp="brand", resp="colonies",
                   type="GrandMean", alternative="less", covar.equal=TRUE)

test_that("Ratio test produces plot", {
    expect_type(anomic(rel, stdep=waterfilter$colonies, stind=waterfilter$brand, xlabel = "Brand", ylabel = "Colony Ratio", printp = FALSE), "object")
})

test_that("Ratio test supplies erroneous grand mean", {
    expect_error(anomic(rel, stdep=waterfilter$colonies, stind=waterfilter$brand, xlabel = "Brand", ylabel = "Colony Ratio", printp = FALSE, gm=10), "gm")
})


test_that("SimCi fails on wrong type of test", {
    expect_error(anomic.SimCi(tukey_het2), "GrandMean")
})

test_that("Missing dependent variable raises error", {
    expect_error(anomic.SimCi(het2, stind=waterfilter$brand, pst=het2p), "dependent")
})

test_that("Missing independent variable raises error", {
    expect_error(anomic.SimCi(het2, stdep=waterfilter$colonies, pst=het2p), "independent")
})

test_that("Incorrect type of dependent variable raises error", {
    expect_error(anomic.SimCi(het2, stdep=waterfilter$brand, stind=waterfilter$brand, pst=het2p), "dependent .* numeric")
})

test_that("Mismatched variables raise error", {
    expect_error(anomic.SimCi(het2, stdep=c(1,2,3), stind=waterfilter$brand, pst=het2p), 
        "equal length")
})

test_that("Missing p values raises error when printp is TRUE", {
    expect_error(anomic.SimCi(het2, stdep=waterfilter$colonies, stind=waterfilter$brand), 
        "SimTest.* pst")
})



## mctp (nparcomp)
library(multcomp)
library(nparcomp)

ss <- tapply(waterfilter$colonies, waterfilter$brand, length)
# Build a grand-mean-type contrast matrix
Mat <- contrMat(ss, "GrandMean")

mult <- mctp(colonies ~ brand, data=waterfilter, type="UserDefined",
             contrast.matrix=Mat, alternative="less", info=FALSE,
             correlation=TRUE, asy.method="mult.t")



tukey_Mat <- contrMat(ss, "Tukey") 
tukey_mult <- mctp(colonies ~ brand, data=waterfilter, type="UserDefined",
             contrast.matrix=tukey_Mat, alternative="less", info=FALSE,
             correlation=TRUE, asy.method="mult.t")



test_that("Wrong type of contrast matrix raises error", {
    expect_error(anomic.mctp(tukey_mult), "GrandMean")
})

no_corr_mult <- mctp(colonies ~ brand, data=waterfilter, type="GrandMean",                                 alternative="less", info=FALSE, correlation=FALSE, asy.method="mult.t")

test_that("Correlation FALSE raises error", {
    expect_error(anomic.mctp(no_corr_mult), "correlation")
})

test_that("Mctp less produces plot", {
    expect_type(anomic(mult), "object")
})

multgreater <- mctp(colonies ~ brand, data=waterfilter, type="UserDefined",
             contrast.matrix=Mat, alternative="greater", info=FALSE,
             correlation=TRUE, asy.method="mult.t")

test_that("Mctp greater produces plot", {
    expect_type(anomic(multgreater), "object")
})

multboth <- mctp(colonies ~ brand, data=waterfilter, type="UserDefined",
             contrast.matrix=Mat, alternative="two.sided", info=FALSE,
             correlation=TRUE, asy.method="mult.t")

test_that("Mctp two sided produces plot", {
    expect_type(anomic(multboth, xlabel = "Brand Number", ylabel = "Colonies", printp = FALSE), "object")
})


multbad <- mctp(colonies ~ brand, data=waterfilter, type="UserDefined",
             contrast.matrix=Mat, alternative="less", info=FALSE,
             correlation=TRUE, asy.method="mult.t")

multbad$Data.Info$Size <- NULL # remove column from model's dataframe

test_that("Mctp removing sample sizes forces error", {
    expect_error(anomic(multbad, printp = FALSE, gm = 144.0526), "Group sizes")
})



# binomRDci 
library(MCPAN)

# indended usage 
wald <- binomRDci(n=math$enrolled, x=math$proficient, names=math$school,
                  alternative="two.sided", method="Wald", type="GrandMean")
waldp <- binomRDtest(n=math$enrolled, x=math$proficient, names=math$school,                   alternative="two.sided", method="Wald", type="GrandMean")

# t_wald <- anomic(wald, pbin=waldp)

tukey_wald <- binomRDci(n=math$enrolled, x=math$proficient, names=math$school,
                  alternative="two.sided", method="Wald", type="Tukey")
test_that("Wrong contrast matrix raises error", {
    expect_error(anomic.binomRDci(tukey_wald), "GrandMean")
})

test_that("Missing test raises error when printp is TRUE", {
    expect_error(anomic.binomRDci(wald), "binomRDtest.* printp")
})

test_that("Intended usage produces plot", {
    expect_type(anomic(wald, pbin=waldp), "object")
})

test_that("Intended usage with printp FALSE produces plot", {
    expect_type(anomic(wald, printp = FALSE), "object")
})

test_that("Label replacement produces plot", {
    expect_type(anomic(wald, pbin=waldp, xlabel = "School", ylabel = "Proficient Proportion"), "object")
})

waldbad <- binomRDci(n=math$enrolled, x=math$proficient, names=math$school,
                  alternative="two.sided", method="Wald", type="GrandMean")
waldbad$conf.int[, "lower"] <- -Inf

test_that("Tampering to mimic one sided produces warning", {
    expect_warning(anomic(waldbad, pbin=waldp), "two.sided")
})


# anomic_nicely internal function

test_that("Annotate without geom arg errors", {
    expect_error(anomic_nicely(annotate), "geom")
})

test_that("Invalid function errors", {
    expect_error(anomic_nicely(binomRDci), "Wrapper")
})

#  -END OF FILE- 
